<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>ReWrite</title>
        <link href="https://fonts.googleapis.com/css2?family=Anton&display=swap" rel="stylesheet">
        <link href="https://fonts.googleapis.com/css2?family=Caveat:wght@400;700&display=swap" rel="stylesheet">
        <link href="https://fonts.googleapis.com/css2?family=Signika:wght@400;700&display=swap" rel="stylesheet">
        <script src="https://d3js.org/d3.v7.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/diff@5.0.0/dist/diff.min.js"></script>
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">

        <script src="http://code.jquery.com/jquery-1.9.1.min.js"></script>
	    <script src="http://code.jquery.com/jquery-migrate-1.0.0.js"></script>
        <script type="text/javascript" src="{{ url_for('static', filename='/lib/rangy/rangy-core.js') }}"></script>
        <script type="text/javascript" src="{{ url_for('static', filename='/polyfills.js') }}"></script>
        <script type="text/javascript" src="{{ url_for('static', filename='/ice.js') }}"></script>
        <script type="text/javascript" src="{{ url_for('static', filename='/dom.js') }}"></script>
        <script type="text/javascript" src="{{ url_for('static', filename='/icePlugin.js') }}"></script>
        <script type="text/javascript" src="{{ url_for('static', filename='/icePluginManager.js') }}"></script>
        <script type="text/javascript" src="{{ url_for('static', filename='/IceAddTitlePlugin.js') }}"></script>
        <script type="text/javascript" src="{{ url_for('static', filename='/IceEmdashPlugin.js') }}"></script>
        <script type="text/javascript" src="{{ url_for('static', filename='/IceCopyPastePlugin.js') }}"></script>
        <script type="text/javascript" src="{{ url_for('static', filename='/bookmark.js') }}"></script>
        <script type="text/javascript" src="{{ url_for('static', filename='/selection.js') }}"></script>
        <script type="text/javascript" src="{{ url_for('static', filename='/lib/tinymce/jscripts/tiny_mce/tiny_mce.js') }}"></script>





        <style>
            body {
                margin: 0;
                height: 100vh;
                background-color: #f0f0f0;
            }
            .title {
                position: absolute;
                top: 10px;
                left: 10px;
                font-size: 36px;
                margin:0;
                font-family: 'Anton', sans-serif;
                font-weight: bold;
            }

            label {
                display: block;
                margin-bottom: 5px;
                font-size: 20px;
                color: black;
                font-weight: bold;
                font-family: 'Anton', sans-serif;
                text-align: center;
            }

            caption {
                font-weight: bold;
                margin-bottom: 10px;
                font-size: 20px;
                font-family: 'Anton', sans-serif;
                color: black;
            }

            .explanation {
                margin-top: 20px;
                font-size: 12px;
                font-family: 'Signika', sans-serif;
                font-weight: bold;
                color: black;
                text-align: center;
            }

            .container {
                display: flex;
                justify-content: space-between;
                margin-top: 60px;
                height: calc(100vh - 60px);
            }
            .left-section {
                width: 65%;
                height: 100%;
                overflow-y: auto;
                padding: 10px;
                box-sizing: border-box;
            }
            .right-section {
                width: 30%;
                height: 80%;
                padding: 10px;
            }
            .step-4-container {
                display: flex;
                align-items: center;
                gap: 10px;
                justify-content: center;
            }

            .step-4-container label {
                /* flex: 1; */
                margin: 0;
            }
            
            .table-chart-container {
                display: flex;
                justify-content: space-between;
                height: 50%;

            }
            .chart-container {
                width: 100%;
                display: flex;
                justify-content: center;
                height: 100%;
            }  

            .edit-table {
                width: 100%;
                display: flex;
                justify-content: center;
                height: 100%;
            }

            textarea.source-text {
                width: 100%;
                height: auto;
                min-height: 100px;
                max-height: 300px;
                margin-bottom: 10px;
                padding: 5px;

                border: 2px solid #ccc;
                border-radius: 10px;

                font-size: 15px;
                font-family: "Comic Sans MS", cursive, sans-serif;
                color: black;

                overflow: auto;
            }
            textarea.essay-prompt {
                width: 100%;
                height: auto;
                min-height: 50px;
                max-height: 100px;
                margin-bottom: 10px;
                padding: 5px;

                border: 2px solid #ccc;
                border-radius: 10px;

                font-size: 15px;
                font-family: "Caveat", cursive;
                color: black;

                overflow: auto;
            }
            .response-box {
                width: 100%;
                height: auto;
                min-height: 400px;
                /* max-height: 800px;
                margin-bottom: 10px;
                padding: 5px; */

                border: 2px solid #ccc;
                /* border-radius: 10px; */
                
                /* font-size: 15px;
                font-family: 'Courier New', Courier, monospace; */

                overflow: auto;
            }
            .submit-button {
                width: 100%;
                height: 50px;
                padding: 5px;
                margin-bottom: 10px;

                background-color: lightblue;

                border: 3px solid;
                border-radius: 10px;

                font-size: 20px;
                color: black;
                font-weight: bold;
                font-family: 'Anton', sans-serif;
                text-align: center;
            }

            .refresh-button {
                width: 100%;
                height: 50px;
                padding: 5px;
                margin-bottom: 20px;
                /* margin-top: 20px; */

                background-color: lightblue;

                border: 3px solid;
                border-radius: 10px;

                font-size: 20px;
                color: black;
                font-weight: bold;
                font-family: 'Anton', sans-serif;
                text-align: center;

                word-wrap: break-word;
                white-space: normal;
                overflow: hidden;

                flex-shrink: 0;

            }

            .toggle-button {
                /* width: 100%; */
                height: 50px;
                padding: 5px;
                margin-bottom: 10px;

                background-color: lightblue;

                border: 3px solid;
                border-radius: 10px;

                font-size: 20px;
                color: black;
                font-weight: bold;
                font-family: 'Anton', sans-serif;
                text-align: center;
            }

            .toggle-button:hover,
            .refresh-button:hover,
            .submit-button:hover {
                background-color: deepskyblue;
            }

            table {
                width: 100%;
                padding: 5px;
                max-width: 600px;
                margin-bottom: 10px;

                border-collapse: collapse;
                border-radius: 10px;
                box-shadow: 0 8px 16px rgba(0, 0, 0, 0.1);

                font-family: 'Signika', sans-serif;
            }
            th, td {
                /* border: 1px solid black; */
                /* border-radius: 10px; */
                padding: 10px;
                text-align: center;
            }

            td {
                color: #333;
                font-size: 30px;
            }

            th {
                font-size: 16px;
                font-weight: bold;
                /* background-color: #333; */
                text-transform: uppercase;
                letter-spacing: 1px;
            }
            /* First Row Elements (Clarify and Assert) */
            #flag-summary-table tr:nth-child(1) th:nth-child(1), #flag-summary-table tr:nth-child(1) td:nth-child(2) {
                background-color: lightcoral; /* Clarify */
            }

            #flag-summary-table tr:nth-child(1) th:nth-child(3), #flag-summary-table tr:nth-child(1) td:nth-child(4) {
                background-color: lightgreen; /* Assert */
            }

            /* Second Row Elements (Fact-Check and Exemplify) */
            #flag-summary-table tr:nth-child(2) th:nth-child(1), #flag-summary-table tr:nth-child(2) td:nth-child(2) {
                background-color: lightblue; /* Fact-Check */
            }

            #flag-summary-table tr:nth-child(2) th:nth-child(3), #flag-summary-table tr:nth-child(2) td:nth-child(4) {
                background-color: pink; /* Exemplify */
            }

            /* Third Row Element (Simplify) */
            #flag-summary-table tr:nth-child(3) th:nth-child(1), #flag-summary-table tr:nth-child(3) td:nth-child(2) {
                background-color: lightsalmon; /* Simplify */
            }

            /* Container to make the edit-table scrollable */
            .edit-table-container {
                max-height: 300px; /* Adjust height as needed */
                overflow-y: auto; /* Add vertical scroll when content overflows */
                border: 1px solid #ccc; /* Optional: border for visual clarity */
                border-radius: 10px; /* Optional: rounded corners */
                box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1); /* Optional: subtle shadow */
            }

            /* Ensure the table within the container takes full width */
            #edit-table {
                width: 100%;
                border-collapse: collapse;
            }

            #edit-table th, #edit-table td {
                padding: 10px;
                text-align: center;
                font-size: 10px; /* Adjust font size to fit within scrollable view */
                border-bottom: 1px solid black;
            }

            #edit-table th {
                background-color: #e0e0e0; /* Light gray for headers */
                position: sticky; /* Keep header visible while scrolling */
                top: 0; /* Required for sticky positioning */
                z-index: 1; /* Ensure header is above table content */
                border-bottom: 2px solid black;
            }

            #edit-table tbody tr:hover {
                background-color: white; /* Highlight row on hover for better visibility */
            }
            #edit-table tbody tr:last-child td {
                border-bottom: none; /* Remove border from the last row for a cleaner finish */
            }
            
            .highlight-row {
                background-color: white;
                transition: background-color 0.3s ease;
            }

            .clarify_row, .clarify_highlight {
                /* background-color: lightcoral; */
                background-color: rgba(240, 128, 128, 0.8);
            }
            .assert_row, .assert_highlight {
                /* background-color: lightgreen; */
                background-color: rgba(144, 238, 144, 0.8);
            }
            .factcheck_row, .factcheck_highlight {
                /* background-color: lightblue; */
                background-color: rgba(173, 216, 230, 0.8);
            }
            .exemplify_row, .exemplify_highlight {
                /* background-color: pink; */
                background-color: rgba(255, 182, 193, 0.8);
            }
            .simplify_row, .simplify_highlight {
                /* background-color: lightsalmon; */
                background-color: rgba(255, 160, 122, 0.8);
            }

            .highlight-span {
                border: 1px solid rgba(0, 0, 0, 0.1);
                position: relative;
            }
            
            .clarify_highlight,
            .assert_highlight,
            .factcheck_highlight,
            .exemplify_highlight,
            .simplify_highlight {
                position: relative;
                cursor: pointer;
                font-weight: bold;
                display: inline;
                white-space: nowrap;
            }

            .tooltip-content {
                display: none;
                position: absolute;
                top: 100%;
                left: 50%;
                transform: translateX(-50%);
                background-color: #fff;
                border: 1px solid #ccc;
                padding: 5px;
                border-radius: 5px;
                box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
                z-index: 1001;
                font-size: 12px;
                text-align: left;
                white-space: normal;
                max-width: 500px;
                word-wrap: break-word;
            }
            
            .tooltip-check {
                display: flex;
                align-items: center;
                gap: 5px;
                font-size: 10px;
                color: #555;
            }
            .tooltip-check input[type="checkbox"] {
                margin: 0;
            }
            .tooltip-check label {
                font-size: 12px;
                margin: 0;
            }

            .tooltip-text {
                font-size: 12px; /* Ensure tooltip text is readable */
                color: #000; /* Standard color for tooltip content */
            }

            .clarify_highlight:hover .tooltip-content,
            .assert_highlight:hover .tooltip-content,
            .factcheck_highlight:hover .tooltip-content,
            .exemplify_highlight:hover .tooltip-content,
            .simplify_highlight:hover .tooltip-content {
                display: block;
            }

            .edit-completed {
                background-color: #f0f0f0;
                color: black;
                text-decoration: none;
            }
            
        </style>
    </head>
    <body>

        <h1 class="title">ReWrite</h1>
        
        <div class="container">

            <!-- Left Section: Text Inputs & Initial Actions -->
            <div class="left-section">

                    <!-- Source Text Input -->
                    <label for="source-input">STEP 1: Enter Source Text</label>
                    <textarea class="source-text" id="source-input" placeholder="Source Text."></textarea>

                    <!-- Essay Prompt Input -->
                    <label for="essay-input">STEP 2: Enter Essay Prompt</label>
                    <textarea class="essay-prompt" id="essay-input" placeholder="Essay Prompt."></textarea>

                    <!-- Submit Button -->
                    <button class="submit-button" id="sub-but">STEP 3: Submit to ReWrite</button>

                    <!-- Response Section -->
                    <div class="step-4-container">
                        <label for="response">STEP 4: Edit Essay</label>
                        <button class="toggle-button" id="highlight-toggle"><i class="fas fa-eye"></i> Show Your Edits!</button>
                    </div>
                    <div class="response-box" id="response-input" contenteditable="true"><p>ReWrite's Response</p></div>

            </div>
            
            
            <!-- Right Section: Evaluation & Feedback -->
            <div class="right-section">

                <!-- Refresh Button -->
                <button class="refresh-button" id="refresh-but">STEP 5: Evaluate Essay</button>

                <div class="table-chart-container">

                    <!-- Flag Summary Table -->
                    <table id="flag-summary-table">
                        <caption id="table-title">Flag Summary 🚩</caption>
                        <tr>
                            <th class="clarify">Clarify!</th>
                            <td id="clarify" class="clarify">0</td>
                            <th class="assert">ASSERT!</th>
                            <td id="assert" class="assert">0</td>
                        </tr>
                        <tr>
                            <th class="factcheck">Fact-Check!</th>
                            <td id="factcheck" class="factcheck">0</td>
                            <th class="exemplify">Exemplify!</th>
                            <td id="exemplify" class="exemplify">0</td>
                        </tr>
                        <tr>
                            <th class="simplify" colspan="2">Simplify!</th>
                            <td id="simplify" class="simplify" colspan="2">0</td>
                        </tr>
                    </table>

                    <!-- Bar Chart -->
                    <div class="chart-container">
                        <svg id="bar-chart" width="100%" height="100%"></svg>
                    </div>
                    
                </div>
                <div class="edit-table-container">

                    <!-- Flag Tracker Table -->
                    <table id="edit-table">
                        <caption id="table-title">Flag Tracker 📋</caption>
                        <thead>
                            <tr>
                                <th>Evaluation #</th>
                                <th>Category</th>
                                <th>Context</th>
                                <th>Suggested Fix</th>
                                <th>Completed</th>
                            </tr>
                        </thead>
                        <tbody></tbody>
                    </table>
                </div>
                
                <!-- Explanatory Message -->
                <div class="explanation">
                    <p>⭐ Address each flag to increase your score and sound more like a human! ⭐</p>
                </div>
                
            </div>
        </div>
        

        <script>



        function wrapTextNodesInBlockElements(element) {
            Array.from(element.childNodes).forEach(node => {
                if (node.nodeType === Node.TEXT_NODE && node.textContent.trim() !== '') {
                    const p = document.createElement('p');
                    p.textContent = node.textContent.trim();
                    element.replaceChild(p, node);
                }
            });
        }

        // Event Listener for the Submit Button
        document.getElementById('sub-but').addEventListener('click', function() {

            // Retrieve input values (source text and essay prompt)
            const sourceText = document.getElementById('source-input').value;
            const essayPrompt = document.getElementById('essay-input').value;
            const submitButton = document.getElementById('sub-but');

            // Validation check
            if (!sourceText || !essayPrompt) {
                console.log("Error: sourceText or essayPrompt are empty.");
                alert("Please fill out both the source text and the essay prompt.");
                return;
            }

            // Loading feedback to user (locks evaluate button to prevent multiple submissions)
            submitButton.innerText = 'Loading...';
            submitButton.disabled = true;
            // document.getElementById('response-input').innerText = "Loading...";
            const responseInput = document.getElementById('response-input');

            // responseInput.innerText = "Loading...";
            responseInput.innerHTML = "<p>Loading...</p>";

            // Send a POST request to /rewrite
            // Request contains the source text and essay prompt
            fetch('/rewrite', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    source_text: sourceText,
                    essay_prompt: essayPrompt
                })
            })

            // Handle server response
            // Parses JSON response, updates response box, and saves the response
            .then(response => response.json())
            .then(data => {
                // document.getElementById('response-input').innerText = data.response;
                // responseInput.innerText = data.response || "<p>Default response content</p>";

                responseInput.innerHTML = data.response || "<p>Default response content</p>";

                wrapTextNodesInBlockElements(responseInput);

                if (!responseInput.firstChild) {
                    console.warn("responseInput is empty. Adding a default <p> node.");
                    responseInput.innerHTML = "<p>Default response content</p>";
                }

                // Reset submit button
                submitButton.innerText = 'STEP 3: Submit to ReWrite';
                submitButton.disabled = false;
                if (!responseInput || !(responseInput instanceof Node) || !responseInput.firstChild) {
                    console.error("Invalid responseInput. Skipping ICE Editor initialization.");
                    return;
                }

                try {
                    var editor = new ice.InlineChangeEditor({
                        element: responseInput,
                    });
                    console.log("Starting to track changes.");
                    editor.startTracking();

                    editor.onChange(function (change) {
                        console.log("Detected change:", change);
                    });

                } catch (error) {
                    console.error("Error starting to track changes:", error);
                }


            })

            // Error handling
            .catch(error => {
                console.error('Error:', error);
                submitButton.innerText = 'STEP 3: Submit to ReWrite';
                submitButton.disabled = false;
            });
        });

        window.addEventListener("load", function () {
    console.log("ice.PluginManager:", typeof ice.PluginManager !== "undefined" ? ice.PluginManager : "Not defined");
});





        document.getElementById('refresh-but').addEventListener('click', async function () {

                const responseBox = document.getElementById('response-input');
                // const sourceBox = document.getElementById('source-input');
                const refreshButton = document.getElementById('refresh-but');

                if (!responseBox.innerText.trim() || responseBox.innerText.trim() === "ReWrite's Response") {
                    console.log("Error: No essay to evaluate.");
                    alert("Please generate a response first.");
                    return;
                }

                const essay = responseBox.innerText;
                // const sourceText = sourceBox.innerText;

                refreshButton.innerText = 'Loading...';
                refreshButton.disabled = true;

                let highlightedText = essay;
                const stats = {
                    simplify: 0,
                    exemplify: 0,
                    factcheck: 0,
                    assert: 0,
                    clarify: 0,
                };

                // Utility function for fetch operations
                async function fetchEdits(endpoint, type, payload) {
                    try {
                        const response = await fetch(endpoint, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(payload),
                        });
                        const data = await response.json();

                        // stats[type] = data[`${type}_number`];
                        (data[`${type}_context`] || []).forEach((phrase, index) => {

                            // const startIndex = essay.indexOf(phrase);
                            // const endIndex = startIndex + phrase.length;

                            // Normalize both the essay and the phrase
                            const normalizedEssay = normalizeText(essay);
                            const normalizedPhrase = normalizeText(phrase);

                            // Find the index of the normalized phrase in the normalized essay
                            const startIndex = normalizedEssay.indexOf(normalizedPhrase);
                            const endIndex = startIndex + normalizedPhrase.length;

                            if (startIndex === -1) {
                                console.warn(`Phrase "${phrase}" not found in text.`);
                                return;
                            }
                            // const phraseRegex = new RegExp(`\\b${phrase.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}\\b`, 'gi');
                            const suggestion = data[`${type}_suggestion`][index] || `No suggestion for this ${type} edit.`;
                            const reasoning = data[`${type}_reasoning`][index] || `No reasoning for this ${type} edit.`;
                            // const highlightId = addEditToTable(evaluateClickCount, type.charAt(0).toUpperCase() + type.slice(1), phrase, suggestion, false);
                            const edit = {
                                type,
                                phrase,
                                suggestion,
                                reasoning,
                                startIndex,
                                endIndex,
                                completed: false,
                            };

                            // highlightedText = highlightedText.replace(
                            //     phraseRegex,
                            //     `<span class="${type}_highlight highlight-span" data-type="${type}" data-highlight-id="${highlightId}" data-suggestion="${suggestion}" data-reasoning="${reasoning}" data-start-index="${startIndex}" data-end-index="${endIndex}">${phrase}<span class="tooltip-content"><span class="tooltip-check"><input type="checkbox" class="edit-check" data-completed="false" onchange="toggleCompletion(this)"><label>Mark as Completed</label></span></span></span>`
                            // );

                            // Push edit to the backend database
                            storeEditInBackend(edit);
                        });
                    } catch (error) {
                        console.error(`Error during ${type} fetch:`, error);
                    }
                }

                async function storeEditInBackend(edit) {
                    try {
                        const response = await fetch('http://127.0.0.1:5000/store-edits', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                            },
                            body: JSON.stringify({ edits: [edit] }),
                        });

                        const data = await response.json();
                        // console.log('Edit successfully stored:', data);
                    } catch (error) {
                        console.error('Error storing edit in backend:', error);
                    }
                }

            async function fetchStoredEdits() {
                try {
                    const response = await fetch('http://127.0.0.1:5000/get-edits', {
                        method: 'GET',
                    });

                    const data = await response.json();
                    // console.log(data.edits);
                    return data.edits;
                } catch (error) {
                    console.error('Error fetching stored edits:', error);
                    return [];
                }
            }

            async function updateTable(storedEdits) {

                const categoryCounts = storedEdits.reduce((counts, edit) => {
                    counts[edit.type] = (counts[edit.type] || 0) + 1;
                    return counts;
                }, {});

                console.log(categoryCounts);

                // Populate table dynamically
                Object.keys(stats).forEach((type) => {
                    try {
                        document.getElementById(`${type}`).innerText = categoryCounts[type] || 0;
                    } catch (error) {
                        console.error(`Error processing type "${type}":`, error);
                        // Optionally, you can handle specific cases here, e.g., setting default values.
                    }
                });
            }

                try {
                    await fetchEdits('/simplify', 'simplify', { essay });
                    await fetchEdits('/exemplify', 'exemplify', { essay });
                    await fetchEdits('/factcheck', 'factcheck', { essay });
                    // await fetchEdits('/factcheck', 'factCheck', { essay, source_text: sourceText });
                    await fetchEdits('/assert', 'assert', { essay });
                    await fetchEdits('/clarify', 'clarify', { essay });

                    await delay(20000);

                    // Fetch all stored edits and apply highlights
                    const storedEdits = await fetchStoredEdits();


                    // storedEdits.forEach((edit) => {
                    //     const phraseRegex = new RegExp(`\\b${edit.phrase.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}\\b`, 'gi');
                    //     highlightedText = highlightedText.replace(
                    //         phraseRegex,
                    //         `<span class="${edit.type}_highlight highlight-span" data-type="${edit.type}" data-suggestion="${edit.suggestion}" data-reasoning="${edit.reasoning}" data-start-index="${edit.startIndex}" data-end-index="${edit.endIndex}">${edit.phrase}<span class="tooltip-content"><span class="tooltip-check"><input type="checkbox" class="edit-check" data-completed="${edit.completed}" onchange="toggleCompletion(this)"><label>Mark as Completed</label></span></span></span>`
                    //     );
                    // });
                    storedEdits.forEach((edit) => {
                        const phraseRegex = new RegExp(`\\b${edit.phrase.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}\\b`, 'gi');

                        highlightedText = highlightedText.replace(phraseRegex, (match) => {
                            // Check if the match is already highlighted
                            const existingMatch = match.match(/<span[^>]*class="([^"]*)"/);
                            const existingTypes = match.match(/data-type="([^"]*)"/);

                            let types = existingTypes ? existingTypes[1].split(',') : [];
                            let newClass = `${edit.type}_highlight highlight-span`;

                            // Add the new type if not already present
                            if (!types.includes(edit.type)) {
                                types.push(edit.type);
                            }

                            // Generate box-shadow styles dynamically
                            const shadowColors = {
                                clarify: 'lightcoral',
                                assert: 'lightgreen',
                                factcheck: 'lightblue',
                                exemplify: 'pink',
                                simplify: 'lightsalmon',
                            };

                            const boxShadows = types
                                .map((type) => `0 0 0 2px ${shadowColors[type]}`)
                                .join(',');

                            // Combine classes if already highlighted
                            if (existingMatch) {
                                const existingClasses = existingMatch[1];
                                if (!existingClasses.includes(edit.type)) {
                                    newClass = `${existingClasses} ${edit.type}_highlight`;
                                }
                            }

                            return `<span class="${newClass}" data-type="${types.join(',')}" data-suggestion="${edit.suggestion}" data-reasoning="${edit.reasoning}" style="--highlight-shadows: ${boxShadows}">${match}</span>`;
                        });
                    });





                    responseBox.innerHTML = highlightedText.replace(/\n/g, '<br>');
                    await updateTable(storedEdits);

                } catch (error) {
                    console.error('Error:', error);
                } finally {
                    refreshButton.innerText = 'STEP 5: Evaluate Essay';
                    refreshButton.disabled = false;
                }
            });

            

            function normalizeText(text) {
                return text.toLowerCase().replace(/[^\w\s]/g, '').trim(); // Remove special characters and convert to lowercase
            }

            function delay(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }




            // function collectEdits() {
            //     const edits = [];
            //     document.querySelectorAll('.highlight-span').forEach((highlight) => {
            //         const type = highlight.dataset.type; // e.g., Simplify, Exemplify
            //         const phrase = highlight.innerText; // Highlighted text
            //         const suggestion = highlight.dataset.suggestion; // Suggestion text
            //         const reasoning = highlight.dataset.reasoning; // Suggestion text
            //         const highlightId = highlight.dataset.highlightId; // Highlight ID
            //         const startIndex = parseInt(highlight.dataset.startIndex, 10); // Start index
            //         const endIndex = parseInt(highlight.dataset.endIndex, 10); // End index
            //         const completed = highlight.querySelector('.edit-check').checked; // Completion status

            //         edits.push({
            //             type,
            //             phrase,
            //             suggestion,
            //             reasoning,
            //             highlightId,
            //             startIndex,
            //             endIndex,
            //             completed,
            //         });
            //     });
            //     return edits;
            // }

            // async function sendEditsToBackend(edits) {
            //     try {
            //         const response = await fetch('http://127.0.0.1:5000/store-edits', {
            //             method: 'POST',
            //             headers: {
            //                 'Content-Type': 'application/json',
            //             },
            //             body: JSON.stringify({ edits }),
            //         });

            //         const data = await response.json();
            //         // console.log('Edits successfully sent:', data);
            //     } catch (error) {
            //         console.error('Error sending edits to backend:', error);
            //     }
            // }


            // setInterval(() => {
            //     const responseBox = document.getElementById('response-input');
            //     const responseBoxText = responseBox ? responseBox.innerText : '';

            //     fetch('/track-edits', {
            //         method: 'POST',
            //         headers: {
            //             'Content-Type': 'application/json',
            //         },
            //         body: JSON.stringify({ responseBoxText }),
            //     })
            //         .then(response => response.json())
            //         .then(data => {
            //             // console.log('Edit tracking response:', data);
            //         })
            //         .catch(error => {
            //             console.error('Error tracking edits:', error);
            //         });
            // }, 3000); // Runs every 3 seconds




        
            

        // // Store the evolving data points for each metric
        // let metricsData = {
        //     Clarify: [0],
        //     Assert: [0],
        //     FactCheck: [0],
        //     Exemplify: [0],
        //     Simplify: [0]
        // };

        // let editCount = 0; // Tracks the number of edits (time)

        // // Function to update the chart data
        // function updateChartData() {
        //     editCount++;

        //     // Get the latest values from the table
        //     metricsData.Clarify.push(parseInt(document.getElementById('clarify').textContent));
        //     metricsData.Assert.push(parseInt(document.getElementById('assert').textContent));
        //     metricsData.FactCheck.push(parseInt(document.getElementById('fact-check').textContent));
        //     metricsData.Exemplify.push(parseInt(document.getElementById('exemplify').textContent));
        //     metricsData.Simplify.push(parseInt(document.getElementById('simplify').textContent));

        //     drawChart();
        // }

        // function drawChart() {
        //     // Clear existing SVG content before re-rendering
        //     d3.select("#bar-chart").selectAll("*").remove();

        //     var chartHeight = document.querySelector('.chart-container').clientHeight;
        //     var margin = {top: 20, right: 20, bottom: 30, left: 60};
        //     var width = document.getElementById("bar-chart").clientWidth - margin.left - margin.right;
        //     var height = chartHeight - margin.top - margin.bottom;

        //     // Create an SVG container
        //     var svg = d3.select("#bar-chart")
        //         .append("svg")
        //         .attr("width", width + margin.left + margin.right)
        //         .attr("height", height + margin.top + margin.bottom)
        //         .append("g")
        //         .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

        //     // X scale: Time (number of edits)
        //     var xScale = d3.scaleLinear()
        //         .domain([0, editCount]) // Number of edits so far
        //         .range([0, width]);

        //     // Y scale: Metric values
        //     var yScale = d3.scaleLinear()
        //         .domain([0, d3.max(Object.values(metricsData).flat())]) // Max value from all metrics
        //         .range([height, 0]);

        //     // Append the Y axis
        //     svg.append("g")
        //         .call(d3.axisLeft(yScale).ticks(5));

        //     // Define custom colors for each metric
        //     const colorMap = {
        //         Clarify: "#F08080",
        //         Assert: "#90EE90",
        //         FactCheck: "#ADD8E6",
        //         Exemplify: "#FFC0CB",
        //         Simplify: "#FFA07A",
        //     };

        //     // Draw lines and circles for each metric
        //     Object.keys(metricsData).forEach((key) => {
        //         svg.append("path")
        //             .datum(metricsData[key])
        //             .attr("fill", "none")
        //             .attr("stroke", colorMap[key]) // Use custom color
        //             .attr("stroke-width", 3) // Increased line width
        //             .attr("d", d3.line()
        //                 .x((d, index) => xScale(index)) // Index is the edit time
        //                 .y(d => yScale(d)) // Metric value
        //             );

        //         // Add circles at each data point
        //         svg.selectAll(".circle-" + key)
        //             .data(metricsData[key])
        //             .enter()
        //             .append("circle")
        //             .attr("cx", (d, index) => xScale(index))
        //             .attr("cy", d => yScale(d))
        //             .attr("r", 4) // Circle radius
        //             .attr("fill", colorMap[key]); // Use custom color
        //     });

        //     // Add title
        //     svg.append("text")
        //         .attr("x", (width / 2))
        //         .attr("y", -5)
        //         .attr("text-anchor", "middle")
        //         .attr("font-size", "16px")
        //         .attr("font-weight", "bold")
        //         .attr("font-family", "'Anton', sans-serif")
        //         .text("Flag Tracker");
        // }



        // // Set up a MutationObserver to detect changes in the table cells
        // const tableObserver = new MutationObserver((mutationsList) => {
        //     for (let mutation of mutationsList) {
        //         if (mutation.type === 'characterData' || mutation.type === 'childList') {
        //             updateChartData();
        //             break; // Update once per batch of mutations
        //         }
        //     }
        // });

        // // Observe changes in the specific table cells
        // ['clarify', 'assert', 'fact-check', 'exemplify', 'simplify'].forEach(id => {
        //     const targetNode = document.getElementById(id);
        //     tableObserver.observe(targetNode, { characterData: true, childList: true, subtree: true });
        // });

        // // Initial chart draw
        // drawChart();


        // var tracker = new ice.InlineChangeEditor({
        //             element: document.getElementById('response-input'),
        //             handleEvents: true,
        //             currentUser: { id: 1, name: 'Miss T' },

        //             }).startTracking();


            
        </script>
    </body>
</html>